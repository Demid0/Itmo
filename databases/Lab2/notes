ВИДЫ ПРЕДСТАВЛЕНИЙ
	- view (можно обновить, но есть нюансы)
	- materialized view (нельзя вставить и удалить данные, можно только удалить целиком)
--ЗА ЭТО МОГУТ УБИТЬ ЛУЧШЕ САМ ПОГУГЛИ --

АРХИТЕКТУРА ANSI-SPARC (трехуровневая архитектура СУБД)
	- пользовательский (представления бд)
	- концептуальный (описание данных, их связи, ограничения)
	- физический (описание как хранятся данные на диске)

ПРИНЦИП ACID (обеспечивает сохранность данных)
	atomicity - атомарность (транзакция либо выполнена, либо нет. Без промежуточных состояний)
	consistency - согласованность (успешно выполненная транзакция сохраняет согласованность бд)
	isolation - изолированность (транзакции не влияют друг на друга)
	durability - устойчивость (выполненные транзакции не откатываются из-за сбоев)

WITH RECURSIVE TEMP (ИД, ОТД_ИД, КОРОТКОЕ_ИМЯ, ПУТЬ) AS (
	SELECT T1.ИД, T1.ОТД_ИД, T1.КОРОТКОЕ_ИМЯ, CAST (T1.ИД AS VARCHAR(50)) AS ПУТЬ 
	FROM Н_ОТДЕЛЫ AS T1 
	WHERE T1.ОТД_ИД IS NULL 
	UNION
	SELECT T2.ИД, T2.ОТД_ИД, T2.КОРОТКОЕ_ИМЯ, CAST (TEMP.ПУТЬ || ' -> ' || T2.ИД AS VARCHAR(50)) 
	FROM Н_ОТДЕЛЫ AS T2 
	JOIN TEMP ON TEMP.ИД = T2.ОТД_ИД
)
SELECT КОРОТКОЕ_ИМЯ, ПУТЬ 
FROM TEMP;


Индекс - список всех значений в группе из одного или нескольких столбцов, отсортированный в каком-либо порядке. Каждое значение имеет указатель на строку в таблице, где это значение встречается.

Индексы создаются по таблицам для ускорения запросов с where, join, min(), max(), sort, group by.

При изменении/удалении содержимого индексированного столбца/добавлении новой строки индекс нужнр обновить.

btree индекс
работа на основе сбалансированного дерева поиска
полезен при использовании совместно с =, >, <, <=, >=, between

hash index
для построения этого индекса используется хэш-функция

gist
обобщенное дерево поиска




!!Сделать как функцию (если человека нет - exception)

VIEW
 HUMAN.NAME, GROUP.NAME, ACTION_DESCRIPTION.DESCRIPTION WHERE ACTION_WITH_GROUP.DESCRIPTION_ID = ACTION_DESCRIPTION.ID 
 Вывести человека, группу и как они взаимодействуют



CREATE VIEW HUMAN_ACTION_WITH_GROUP_V
AS
	SELECT human.name AS Человек, action_description.description AS Что_сделал, "group".name AS С_какой_группой
	FROM human
	JOIN action_description
	ON action_description.human_id = human.id
	JOIN action_with_group
	ON action_with_group.description_id = action_description.id
	JOIN "group"
	ON "group".id = action_with_group.group_id;



системные представления (5 пункт рубежки) для 1 лабы


cube, rollup, grouping sets

накопительные суммы оценок 
группа, человек, дисциплина, сумма оценок человека 
over partition

пропустить их через explain (analyze)
\i 
psql -f